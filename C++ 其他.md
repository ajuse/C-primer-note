* lambda

  形式：\[capture list](parameters list) -> return type {bady}
  example：

  ```c++
  [](int x, int y) {return x+y;}
  [](int x, int y) -> int {int z = x+y; return z;}
  ```

  1. 可以忽略参数列表和返回类型，但是捕获列表和函数体必须有;
  2. lambda不能有默认参;
  3. 捕获列表可以使用值传递和引用传递，使用引用传递时必须保证在lambda执行期间引用对象存在;
  4. 隐式捕获；使用[=],[&],[=,&]的方式，lambda会推测需要使用的参数并拷贝值或引用；
  5. 混合使用隐式或者显式捕获时，捕获列表的第一个元素必须是&或=，并且使用隐式引用则显式为值，或者隐式值则显式引用;
  6. 值捕获时在lambda创建的时候拷贝而不是在调用的时候拷贝；
  7. 使用关键字mutable可以修改捕获变量的值；`[] () mutable {}`

* 字面值类型
  算术类型，引用，指针等等
  
* inline内联函数
  1. inline可避免函数调用的开销，会在每个调用点展开；
  2. inline说明只是想编译器发出的一个请求，编译器可以选择忽略这个请求；
  3. 一般来说，inline机制用于优化规模小，流程直接，频繁调用的函数，需要编译器都不支持内联递归函数；；
  
* constexpr函数
  1. 能用于常量表达式的函数，函数的返回类型及所有形参的类型都得是字面类型且函数体中有且只有一条return语句；
  2. 编译时即能计算出值，也可能计算不出，关键看计算的依赖的值是否也能够在编译时计算出来；
  3. constexpr被隐式指定为inline函数；
  4. C++11 以后，建议凡是「常量」语义的场景都使用constexpr，只对「只读」语义使用const；
  5. constexpr和inline通常定义在头文件中；
  6. constexpr把所定义的对象置为顶层const
  7. 判断一个对象或表达式是否是常量表达式，由它的数据类型和初始值共同决定；
  
* const

  1. const仅在文件内有效，当然也可以使用extern使其他文件也能访问；
  2. const修饰变量时分为顶层const和底层const，注意的一点：指针既可以是顶层const也可以是底层const；
  3. 顶层const：表示指针本身是个常量；对任何数据类型都适用
  4. 底层const：表示指针所指的对象是个常量；用于声明引用的都是底层const，指针既可以是底层也可以是顶层；
  5. const对象必须初始化；常量指针必须初始化；==初始化时顶层const会被忽略==，传递参数时也一样；
  6. 不改变const操作还有一种是初始化，利用一个对象去初始化另一个对象，则它们是不是const都无关紧要；
     因为是值的拷贝，并不会造成对象值的改变；
  7. 把引用绑定到const对象上称为对常量的引用，对常量的引用不能修改引用所绑定的对象；
  8. 引用的类型必须与被引用的对象类型一致；除了在常量引用初始化时；
  9. 注意初始化赋值时的临时量（临时量对象，一般在初始化中类型不一样或有运算时），特别是引用赋值；
  10. 执行拷贝操作时，顶层const不用在意，底层const则必须一样；

* 类型转换

  1. 类的类型转换
     public继承可以将派生类转换为基类，其他继承类型则不行；多重继承一样；
     转换后不能访问派生类成员函数

* 