* lambda

* 字面值类型
  算术类型，引用，指针等等
  
* inline内联函数
  1. inline可避免函数调用的开销，会在每个调用点展开；
  2. inline说明只是想编译器发出的一个请求，编译器可以选择忽略这个请求；
  3. 一般来说，inline机制用于优化规模小，流程直接，频繁调用的函数，需要编译器都不支持内联递归函数；；
  
* constexpr函数
  1. 能用于常量表达式的函数，函数的返回类型及所有形参的类型都得是字面类型且函数体中有且只有一条return语句；
  2. 编译时即能计算出值，也可能计算不出，关键看计算的依赖的值是否也能够在编译时计算出来；
  3. constexpr被隐式指定为inline函数；
  4. C++11 以后，建议凡是「常量」语义的场景都使用constexpr，只对「只读」语义使用const；
  5. constexpr和inline通常定义在头文件中；
  6. constexpr把所定义的对象置为顶层const
  7. 判断一个对象或表达式是否是常量表达式，由它的数据类型和初始值共同决定；
  
* const

  1. const仅在文件内有效，当然也可以使用extern使其他文件也能访问；

  2. const修饰变量时分为顶层const和底层const，注意的一点：指针既可以是顶层const也可以是底层const；

  3. 顶层const：表示指针本身是个常量；对任何数据类型都适用

  4. 底层const：表示指针所指的对象是个常量；用于声明引用的都是底层const，指针既可以是底层也可以是顶层；
  5. const对象必须初始化；常量指针必须初始化；==初始化时顶层const会被忽略==，传递参数时也一样；
  6. 不改变const操作还有一种是初始化，利用一个对象去初始化另一个对象，则它们是不是const都无关紧要；
     因为是值的拷贝，并不会造成对象值的改变；
  7. 把引用绑定到const对象上称为对常量的引用，对常量的引用不能修改引用所绑定的对象；
  8. 引用的类型必须与被引用的对象类型一致；除了在常量引用初始化时；
  9. 注意初始化赋值时的临时量（临时量对象，一般在初始化中类型不一样或有运算时），特别是引用赋值；

* 