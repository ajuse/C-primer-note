#### C++ Note

* lambda表达式
  比如：\[capture list](parameters list)->return-type{bady}
  example：\[](int x, int y){return x+y;}，\[](int x, int y) -> int {int z = x+y; return z;}
  可以忽略参数列表和返回类型，但是捕获列表和函数体必须有
  lambda不能有默认参
  捕获列表可以使用值传递和引用传递，使用引用传递时必须保证在lambda执行期间引用对象存在
  混合使用隐式或者显式捕获时，捕获列表的第一个元素必须是&或=，并且使用隐式引用则显式为值，或者隐式值则显式引用
  
* 引用和指针的区别：
  1. 引用在创建的时候必须初始化，指针可以在任何时候初始化；
  2. 引用不能为空，必须指向合法的内存；
  3. 引用被初始化为一个对象时，不能再指向另一个对象，即不能再被赋值；
  
* 类修饰符
  public，private，protected；默认为private

* 成员类型：
  公有成员：外部都可以访问；
  私有成员：外部不可访问，只有类和友元函数可以访问；一般可以定义公有成员函数来访问私有成员，以达到外部访问的目的，另外也是保护内部数据的方式；
  保护成员：与私有成员类似，但是保护成员可以在派生类（或子类）中访问；

* 关于三种继承方式

  1. public继承；基类的public，protected，private变为public，protected，private
  2. protected继承，基类的public，protected，private变为protected，protected，private
  3. private继承，基类的public，protected，private变为private，private，private

  注意：private成员只能被本类和友元函数访问，protected成员可以被子类访问

* 构造函数
  可用于初始化类变量，可以使用初始化列表来初始化字段A::A(int m, int n):M(m),N(n){}

* 析构函数
  不能带参数；删除对象时调用，可以用来关闭文件，释放内存等；

* 拷贝构造函数？

* 友元函数和友元类
  可以访问类的私有成员和保护成员，虽然声明在类public中，但不属于类的成员；

* 内联函数
  在编译时会展开副本，调用时不必再找，函数如果修改了，调用的地方都会更新；
  由于会被展开，那么就相当于代码量变大，调用的地方多，相当于编译的时间多；
  所以，内联函数最好小，不超过10行；再需要频繁调用的地方使用，可以提高性能；

* this指针
  每一个对象都能通过 this指针来访问自己的地址。this指针是所有成员函数的隐含参数。
  因此，在成员函数内部，它可以用来指向调用对象。 
  this本质上是类的局部变量，作为成员函数的形参传递(由编译器完成)，也只能在类内部使用；
  友元函数没有this指针，因为不是成员函数。

* 类的静态成员变量
  使用static关键字定义静态成员变量，无论有多少个类对象，静态成员变量就只有一个副本，即所有对象共享静态成员变量； 如果不存在其他的初始化语句，在创建第一个对象时，所有的静态数据都会被初始化为零。 

* 类的静态成员函数
  静态成员函数可以在对象不存在的情况下访问，使用::即可；
  静态成员函数可以访问类的静态成员，静态成员函数和类外部的其他函数；
  静态成员函数没有this指针；

* 派生类继承基类
  基本上继承了基类的所有方法，除了以下方法：

  1. 基类的构造函数、析构函数和拷贝构造函数
  2. 基类的重载运算符
  3. 基类的友元函数

* 多重继承，派生类继承多个基类，class C: public A, public B{}
  对于构造函数初始化，要一个一个初始化；  `C(int a, int b, int c): A(int a), B(b), c(c);`   

* 三层继承，class B: public A{}    class C: public B{}
  对于构造函数初始化，要一层一层初始化；  `C(int a, int b, int c): B(int a, int b), c(c);`   

* 关于派生类变量和函数重名，优先使用派生类的空间，使用其他的类变量或函数需要加上命名空间；

* 虚继承
  派生类无论继承几个类，最终就只有一个类副本

* 虚函数
  虚函数 是在基类中使用关键字 virtual 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。

* 纯虚函数
  想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。  virtual int area() = 0; 

* 多态
  通过使用派生类和虚函数或纯虚函数，在派生类中实现相同成员函数，表现出同一个函数名功能的多样性
  
* 关联容器
  
  set(multiset,unodered_set)和map(multimap,unordered_map)，set和map的关键字都是const
  pair模板
  操作：
  set：begin(),end(),insert(),erase(),find(),count()
  map: erase(),find()
  pair: make_pair(key,val),insert({key,val}),erase()














