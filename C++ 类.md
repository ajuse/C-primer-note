* 构造函数
  1. 构造函数不能声明为const
  2. 只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数
  
* 默认构造函数
  在没有为类提供任何构造函数的时候，编译器会自动提供默认构造函数；
  一旦定义了类的构造函数，则必须使用定义的构造函数。

* 析构函数
  使用~加上类名，析构函数没有参数，常用作程序的清理工作，比如构造时new，那么析构函数delete

* this指针

  1. 作为隐含的参数传递给本类成员函数（方法）；每次成员函数存取数据成员时都隐式使用this指针；
  2. this指针指向调用对象，即可以将this作为调用对象的别名，同样可以访问成员；
  3. this指针被隐含的声明为 `ClassName* const this`；即不能对this进行赋值操作； 

* 类初始化列表
  C++11可以使用列表初始化类，只要提供与类的某个构造函数参数相匹配的内容，用大括号包含起来
  初始化类的列表可以不用写完整，只要命中构造函数，可以提供默认值

* 成员初始化列表
  
  更高效，少了一次调用默认构造函数的过程

  常使用的场景：
  
  1. 常量成员
  2. 引用类型
  3. 没有默认构造函数的类类型
  
* 面向对象的特征

  1. 封装

     类可以自己控制信息的公开与隐藏，通过public，private，protected

  2. 继承

     基类派生为多个子类

  3. 多态

     多种形态显示，以封装和继承为基础

     重载多态。编译时，函数重载，运算符重载；

     子类型多态。运行时，虚函数；

     参数多态。编译时，类模板，函数模板；

     强制多态。编译时或运行时，基本类型转换，强制类型转换；

* const成员函数

  ```c++
  void show() const; //在函数括号后面加上const关键字可以声明一个const成员函数 —— 保证不会修改调用对象
  ```

* 静态成员变量

  1. 静态成员变量无论被继承多少次，就只有一个副本

* 静态成员函数
  
* 虚函数
  
  1. 虚函数的作用是为了能够在它的子类中可以被覆盖override，通过后期绑定来达到多态；
  2. 虚函数在子类中可以不重写；纯虚函数则在子类中必须实现；
  
* 纯虚函数
  
  1. 纯虚函数只是一个接口，一个函数声明而已，具体的实现要留到子类中去实现；
  2. 纯虚函数必须在子类实现才可以实例化子类；
  3. 带有纯虚函数的类叫抽象类，这种类不能生成对象，只能被继承并重写其虚函数后才能使用；
  
* 虚析构函数

  虚析构函数是为了解决基类的指针指向派生类对象，并用基类的指针删除派生类对象；

  ```C++
  class A {
  public: 
  		virtual ~A();
  };
  class B : public A {
  public:
  		~B();
  }
  int main(){
  		A* pa = new B;
  		// 因为A有虚析构函数，所以delete释放内存时，先调用子类析构函数，再调用基类虚构函数，防止内存泄露；
  		delete pa; 
  }
  ```

* 虚函数指针和虚函数表

  虚函数指针：在含有虚函数的对象中，指向虚函数表，在运行是确定

  虚函数表：存在于只读数据段中，用于存放虚函数指针，如果子类中实现了基类中的某个虚函数，则在虚函数表中覆盖原本基类的那个函数指针，在编译时根据类的声明创建；

* 虚继承
  
  虚继承用于解决多继承条件下的菱形问题（浪费存储空间，存在二义性）
  
  一般通过虚基类指针和虚基类表实现
  
* 类的自动转换和强制自动转换

* 类的继承

